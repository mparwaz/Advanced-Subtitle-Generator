<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Subtitle Generator</title>

  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23667eea'/%3E%3Ctext x='32' y='42' font-family='Segoe UI, Tahoma, Geneva, Verdana, sans-serif' font-size='32' fill='white' text-anchor='middle' font-weight='bold'%3ES%3C/text%3E%3C/svg%3E" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

#targetLang option {
  background-color: #000000; /* or a dark color that contrasts */
  color: #ffffff; /* white text */
}

#targetLang option:hover, 
#targetLang option:focus {
  background-color: #667eea; /* or your highlight color */
  color: #ffffff; /* keep text readable */
}

#modelSelect option {
  color: #000; /* set option text color visible on your background */
  background-color: #fff; /* set a contrasting background */
}

#modelSelect option:hover,
#modelSelect option:focus {
  background-color: #667eea; /* your hover color */
  color: #fff; /* hover text color */
}


    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .controls-panel {
      background: rgba(255, 255, 255, 0.05);
      padding: 25px;
      border-radius: 15px;
      margin-bottom: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #a0a0ff;
    }

    input[type="file"], select, input[type="text"], input[type="number"], input[type="color"] {
      width: 100%;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    input[type="file"]:hover, select:hover, input[type="text"]:hover, input[type="number"]:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(102, 126, 234, 0.5);
    }

    .btn-group {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    button {
      flex: 1;
      min-width: 150px;
      padding: 14px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .video-container {
      position: relative;
      background: #000;
      border-radius: 15px;
      overflow: hidden;
      margin-bottom: 25px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    video {
      width: 100%;
      display: block;
      max-height: 500px;
    }

    .subtitle-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      text-align: center;
      pointer-events: none;
      padding: 20px;
    }

    .subtitle-text {
      display: inline-block;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .timeline-editor {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-height: 500px;
      overflow-y: auto;
    }

    .timeline-item {
      background: rgba(255, 255, 255, 0.08);
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
      transition: all 0.3s ease;
    }

    .timeline-item:hover {
      background: rgba(255, 255, 255, 0.12);
      transform: translateX(5px);
    }

    .timeline-item.active {
      border-left-color: #f093fb;
      background: rgba(240, 147, 251, 0.15);
    }

    .timeline-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 2fr;
      gap: 10px;
      margin-top: 10px;
    }

    .timeline-controls input {
      padding: 8px;
      font-size: 13px;
    }

    .status {
      background: rgba(102, 126, 234, 0.2);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      border-left: 4px solid #667eea;
      display: none;
    }

    .status.show {
      display: block;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
      margin-top: 10px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.3s ease;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .style-preview {
      margin-top: 15px;
      padding: 20px;
      background: #000;
      border-radius: 10px;
      text-align: center;
    }

    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
      
      .btn-group {
        flex-direction: column;
      }
      
      button {
        min-width: 100%;
      }
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>üé¨ Advanced Subtitle Generator</h1>
    <!-- Your existing controls and UI as before, unchanged -->

    <!-- Status Display -->
    <div id="status" class="status">
      <div id="statusText">Ready</div>
      <div class="progress-bar"><div id="progressFill" class="progress-fill"></div></div>
    </div>

    <!-- Video player, controls, timeline, export buttons etc. -->
<!-- Video Upload Controls -->
    <div class="controls-panel">
      <h2 style="margin-bottom: 15px;">üìÇ Video Upload</h2>
      <div class="control-group">
        <label for="videoInput">Select Video File</label>
        <input type="file" id="videoInput" accept="video/*" />
  <div id="generationInfo" style="margin-top: 12px; font-weight: 600; color: #a0a0ff;"></div>
      </div>

      <div class="control-group">
        <label for="modelSelect">Whisper Model</label>
        <select id="modelSelect">
          <option value="tiny.en">Tiny (English, ~40MB, Fast)</option>
          <option value="tiny">Tiny (Multilingual, ~40MB)</option>
          <option value="base.en" selected>Base (English, ~75MB, Recommended)</option>
          <option value="base">Base (Multilingual, ~75MB)</option>
          <option value="small.en">Small (English, ~245MB, High Quality)</option>
          <option value="small">Small (Multilingual, ~245MB)</option>
        </select>
      </div>

      <div class="btn-group">
        <button id="generateBtn">üéôÔ∏è Generate Subtitles</button>
        <button id="loadModelBtn">‚¨áÔ∏è Download Model</button>
      </div>
    </div>

    <!-- Video Player with Subtitle Overlay -->
    <div class="video-container">
      <video id="video" controls></video>
      <div class="subtitle-overlay">
        <div id="subtitleDisplay" class="subtitle-text" style="display: none;"></div>
      </div>
    </div>

    <!-- Subtitle Style Controls -->
    <div class="controls-panel">
      <h2 style="margin-bottom: 15px;">üé® Subtitle Styling</h2>
      <div class="grid-2">
        <div class="control-group">
          <label for="fontColor">Font Color</label>
          <input type="color" id="fontColor" value="#ffffff" />
        </div>
        <div class="control-group">
          <label for="fontSize">Font Size (px)</label>
          <input type="number" id="fontSize" value="24" min="12" max="72" />
        </div>
        <div class="control-group">
          <label for="bottomOffset">Bottom Offset (px)</label>
          <input type="number" id="bottomOffset" value="20" min="0" max="200" />
        </div>
        <div class="control-group">
          <label for="bgOpacity">Background Opacity</label>
          <input type="number" id="bgOpacity" value="0.7" min="0" max="1" step="0.1" />
        </div>
      </div>
      <div class="style-preview">
        <div id="stylePreview" class="subtitle-text">Preview Subtitle Text</div>
      </div>
    </div>

    <!-- Translation Controls -->
    <div class="controls-panel">
      <h2 style="margin-bottom: 15px;">üåç Translation</h2>
      <div class="grid-2">
        <div class="control-group">
          <label for="translateToggle">
            <input type="checkbox" id="translateToggle" style="width: auto; margin-right: 8px;" />
            Enable Translation
          </label>
        </div>
        <div class="control-group">
          <label for="targetLang">Target Language</label>
          <select id="targetLang">
             <option value="af">Afrikaans</option>
  <option value="sq">Albanian</option>
  <option value="am">Amharic</option>
  <option value="ar">Arabic</option>
  <option value="hy">Armenian</option>
  <option value="az">Azerbaijani</option>
  <option value="eu">Basque</option>
  <option value="be">Belarusian</option>
  <option value="bn">Bengali</option>
  <option value="bs">Bosnian</option>
  <option value="bg">Bulgarian</option>
  <option value="ca">Catalan</option>
  <option value="ceb">Cebuano</option>
  <option value="zh">Chinese (Simplified)</option>
  <option value="zh-TW">Chinese (Traditional)</option>
  <option value="co">Corsican</option>
  <option value="hr">Croatian</option>
  <option value="cs">Czech</option>
  <option value="da">Danish</option>
  <option value="nl">Dutch</option>
  <option value="en" selected>English</option>
  <option value="eo">Esperanto</option>
  <option value="et">Estonian</option>
  <option value="fi">Finnish</option>
  <option value="fr">French</option>
  <option value="fy">Frisian</option>
  <option value="gl">Galician</option>
  <option value="ka">Georgian</option>
  <option value="de">German</option>
  <option value="el">Greek</option>
  <option value="gu">Gujarati</option>
  <option value="ht">Haitian Creole</option>
  <option value="ha">Hausa</option>
  <option value="haw">Hawaiian</option>
  <option value="he">Hebrew</option>
  <option value="hi">Hindi</option>
  <option value="hmn">Hmong</option>
  <option value="hu">Hungarian</option>
  <option value="is">Icelandic</option>
  <option value="ig">Igbo</option>
  <option value="id">Indonesian</option>
  <option value="ga">Irish</option>
  <option value="it">Italian</option>
  <option value="ja">Japanese</option>
  <option value="jv">Javanese</option>
  <option value="kn">Kannada</option>
  <option value="kk">Kazakh</option>
  <option value="km">Khmer</option>
  <option value="rw">Kinyarwanda</option>
  <option value="ko">Korean</option>
  <option value="ku">Kurdish (Kurmanji)</option>
  <option value="ky">Kyrgyz</option>
  <option value="lo">Lao</option>
  <option value="la">Latin</option>
  <option value="lv">Latvian</option>
  <option value="lt">Lithuanian</option>
  <option value="lb">Luxembourgish</option>
  <option value="mk">Macedonian</option>
  <option value="mg">Malagasy</option>
  <option value="ms">Malay</option>
  <option value="ml">Malayalam</option>
  <option value="mt">Maltese</option>
  <option value="mi">Maori</option>
  <option value="mr">Marathi</option>
  <option value="mn">Mongolian</option>
  <option value="my">Myanmar (Burmese)</option>
  <option value="ne">Nepali</option>
  <option value="no">Norwegian</option>
  <option value="ny">Nyanja (Chichewa)</option>
  <option value="or">Odia</option>
  <option value="ps">Pashto</option>
  <option value="fa">Persian</option>
  <option value="pl">Polish</option>
  <option value="pt">Portuguese</option>
  <option value="pa">Punjabi</option>
  <option value="ro">Romanian</option>
  <option value="ru">Russian</option>
  <option value="sm">Samoan</option>
  <option value="gd">Scots Gaelic</option>
  <option value="sr">Serbian</option>
  <option value="st">Sesotho</option>
  <option value="sn">Shona</option>
  <option value="sd">Sindhi</option>
  <option value="si">Sinhala</option>
  <option value="sk">Slovak</option>
  <option value="sl">Slovenian</option>
  <option value="so">Somali</option>
  <option value="es">Spanish</option>
  <option value="su">Sundanese</option>
  <option value="sw">Swahili</option>
  <option value="sv">Swedish</option>
  <option value="tl">Tagalog (Filipino)</option>
  <option value="tg">Tajik</option>
  <option value="ta">Tamil</option>
  <option value="tt">Tatar</option>
  <option value="te">Telugu</option>
  <option value="th">Thai</option>
  <option value="tr">Turkish</option>
  <option value="tk">Turkmen</option>
  <option value="uk">Ukrainian</option>
  <option value="ur">Urdu</option>
  <option value="ug">Uyghur</option>
  <option value="uz">Uzbek</option>
  <option value="vi">Vietnamese</option>
  <option value="cy">Welsh</option>
  <option value="xh">Xhosa</option>
  <option value="yi">Yiddish</option>
  <option value="yo">Yoruba</option>
  <option value="zu">Zulu</option>          </select>
        </div>
        <div class="control-group">
          <label for="apiKey">LibreTranslate API Key (Optional)</label>
          <input type="text" id="apiKey" placeholder="Leave empty for public instance" />
        </div>
        <div class="control-group">
          <label for="apiUrl">LibreTranslate API URL</label>
          <input type="text" id="apiUrl" value="https://libretranslate.com/translate" />
        </div>
      </div>
    </div>

    <!-- Timeline Editor -->
    <div class="controls-panel">
      <h2 style="margin-bottom: 15px;">‚è±Ô∏è Timeline Editor</h2>
      <div id="timelineEditor" class="timeline-editor">
        <p style="text-align: center; opacity: 0.6;">Subtitles will appear here after generation...</p>
      </div>
    </div>

    <!-- Export Controls -->
    <div class="controls-panel">
      <div class="btn-group">
        <button id="downloadSRT">‚¨áÔ∏è Download SRT</button>
        <button id="downloadVTT">‚¨áÔ∏è Download VTT</button>
        <button id="applyStyles">‚ú® Apply Styles</button>
        <button id="translateAll">üåê Translate All</button>
      </div>
    </div>

  </div>

  <script type="module">
  let videoFile = null;
  let subtitles = [];
  let currentSubtitleIndex = -1;
  const speedFactor = 1.5;

  const video = document.getElementById('video');
  const videoInput = document.getElementById('videoInput');
  const generateBtn = document.getElementById('generateBtn');
  const loadModelBtn = document.getElementById('loadModelBtn');
  const subtitleDisplay = document.getElementById('subtitleDisplay');
  const timelineEditor = document.getElementById('timelineEditor');
  const statusDiv = document.getElementById('status');
  const statusText = document.getElementById('statusText');
  const progressFill = document.getElementById('progressFill');
  const modelSelect = document.getElementById('modelSelect');
  const translateAllBtn = document.getElementById('translateAll');
  const generationInfo = document.getElementById('generationInfo');

  function formatMinutesToHoursAndMinutes(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.round(totalMinutes % 60);
    return `${hours} hour${hours !== 1 ? 's' : ''} and ${minutes} minute${minutes !== 1 ? 's' : ''}`;
  }

  function mergeOverlappingSubtitles(chunks) {
    if (!chunks.length) return [];

    // Sort chunks by start timestamp
    const sorted = [...chunks].sort((a, b) => (a.timestamp?.[0] || 0) - (b.timestamp?.[0] || 0));

    const merged = [];
    let current = { ...sorted[0], text: sorted[0].text.trim() };

    for (let i = 1; i < sorted.length; i++) {
      const chunk = sorted[i];
      const chunkStart = chunk.timestamp?.[0] || 0;
      const chunkEnd = chunk.timestamp?.[1] || (chunkStart + 3);

      // If overlap or contiguous, merge text and extend end
      if (chunkStart <= (current.timestamp?.[1] || 0) + 0.5) { // 0.5 sec tolerance
        current.timestamp[1] = Math.max(current.timestamp[1], chunkEnd);
        current.text += " " + chunk.text.trim();
      } else {
        merged.push({ 
          id: merged.length + 1,
          start: current.timestamp[0],
          end: current.timestamp[1],
          text: current.text,
          translatedText: null,
        });
        current = { ...chunk, text: chunk.text.trim() };
      }
    }

    // Push last merged chunk
    merged.push({ 
      id: merged.length + 1,
      start: current.timestamp[0],
      end: current.timestamp[1],
      text: current.text,
      translatedText: null,
    });

    return merged;
  }

  videoInput.addEventListener('change', () => {
    if (videoInput.files.length === 0) {
      generationInfo.textContent = '';
      return;
    }
    videoFile = videoInput.files[0];
    const videoURL = URL.createObjectURL(videoFile);
    const tempVideo = document.createElement('video');
    tempVideo.preload = 'metadata';
    tempVideo.src = videoURL;
    tempVideo.onloadedmetadata = () => {
      const durationMinutes = tempVideo.duration / 60;
      const estTime = durationMinutes * speedFactor;
      generationInfo.textContent = `Estimated subtitle generation time: ${formatMinutesToHoursAndMinutes(estTime)} (for a video of ${durationMinutes.toFixed(1)} minutes)`;
      URL.revokeObjectURL(videoURL);
    };
    video.src = videoURL;
    showStatus('Video loaded successfully!');
  });

  const worker = new Worker('worker.js', { type: 'module' });

  worker.onmessage = (e) => {
    const { action } = e.data;
    if (action === 'modelLoaded') {
      showStatus('Model loaded successfully!', 100);
      loadModelBtn.textContent = '‚úÖ Model Ready';
      loadModelBtn.disabled = false;
      generateBtn.disabled = false;
    } else if (action === 'progress') {
      const progress = e.data.progress;
      showStatus(`Transcribing audio... (${progress}%)`, progress);
      if (videoFile) {
        const durationMinutes = video.duration / 60;
        const totalEstTime = durationMinutes * speedFactor;
        const remainingTime = Math.max(0, totalEstTime * (1 - progress / 100));
        generationInfo.textContent = `Estimated subtitle generation time remaining: ${formatMinutesToHoursAndMinutes(remainingTime)} (for a video of ${durationMinutes.toFixed(1)} minutes)`;
      }
    } else if (action === 'transcriptionResult') {
      const rawChunks = e.data.result.chunks || [e.data.result];
      subtitles = mergeOverlappingSubtitles(rawChunks);
      showStatus(`Generated ${subtitles.length} subtitles!`, 100);
      generationInfo.textContent = '';
      renderTimeline();
      generateBtn.disabled = false;
    } else if (action === 'translationResult') {
      const { translatedText, index } = e.data;
      subtitles[index].translatedText = translatedText;
      renderTimeline();
    } else if (action === 'error') {
      showStatus(`Error: ${e.data.message}`);
      console.error('Worker error:', e.data.message);
      generateBtn.disabled = false;
      loadModelBtn.disabled = false;
      translateAllBtn.disabled = false;
    }
  };

  loadModelBtn.addEventListener('click', () => {
    const modelName = modelSelect.value;
    showStatus(`Loading ${modelName} model...`, 0);
    loadModelBtn.disabled = true;
    worker.postMessage({ action: 'loadModel', data: { modelName } });
  });

  generateBtn.addEventListener('click', async () => {
    if (!videoFile) {
      alert('Please select a video file first!');
      return;
    }
    generateBtn.disabled = true;
    showStatus('Extracting audio from video...', 10);
    const audioBuffer = await extractAudio(videoFile);
    showStatus('Transcribing audio with Whisper...', 30);
    worker.postMessage({ action: 'transcribe', data: { audioBuffer } });
  });

  translateAllBtn.addEventListener('click', async () => {
    if (!document.getElementById('translateToggle').checked) {
      alert('Please enable translation first!');
      return;
    }
    if (subtitles.length === 0) {
      alert('No subtitles to translate!');
      return;
    }
    translateAllBtn.disabled = true;

    for (let i = 0; i < subtitles.length; i++) {
      showStatus(`Translating subtitle ${i + 1}/${subtitles.length}...`, (i / subtitles.length) * 100);
      worker.postMessage({
        action: 'translate',
        data: {
          text: subtitles[i].text,
          sourceLang: 'en',
          targetLang: document.getElementById('targetLang').value,
          apiUrl: document.getElementById('apiUrl').value,
          apiKey: document.getElementById('apiKey').value,
          index: i,
        },
      });
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
    translateAllBtn.disabled = false;
  });

  document.getElementById('downloadSRT').addEventListener('click', () => {
    if (subtitles.length === 0) {
      alert('No subtitles to download!');
      return;
    }
    const srtContent = subtitles
      .map((sub) => {
        const start = formatTime(sub.start).replace('.', ','); 
        const end = formatTime(sub.end).replace('.', ',');
        const text = sub.translatedText || sub.text || '';
        return `${sub.id}\n${start} --> ${end}\n${text}\n`;
      })
      .join('\n');

    const blob = new Blob([srtContent], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'subtitles.srt';
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove();
  });

  document.getElementById('downloadVTT').addEventListener('click', () => {
    if (subtitles.length === 0) {
      alert('No subtitles to download!');
      return;
    }
    let vttContent = 'WEBVTT\n\n';
    vttContent += subtitles
      .map((sub) => {
        const start = formatTime(sub.start).replace(',', '.');
        const end = formatTime(sub.end).replace(',', '.');
        const text = sub.translatedText || sub.text || '';
        return `${sub.id}\n${start} --> ${end}\n${text}\n`;
      })
      .join('\n');

    const blob = new Blob([vttContent], { type: 'text/vtt;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    a.download = 'subtitles.vtt';
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    a.remove();
  });

  document.getElementById('applyStyles').addEventListener('click', () => {
    const fontColor = document.getElementById('fontColor').value;
    const fontSize = document.getElementById('fontSize').value;
    const bottomOffset = document.getElementById('bottomOffset').value;
    const bgOpacity = document.getElementById('bgOpacity').value;

    subtitleDisplay.style.color = fontColor;
    subtitleDisplay.style.fontSize = `${fontSize}px`;
    subtitleDisplay.style.bottom = `${bottomOffset}px`;
    subtitleDisplay.style.backgroundColor = `rgba(0, 0, 0, ${bgOpacity})`;

    const preview = document.getElementById('stylePreview');
    preview.style.color = fontColor;
    preview.style.fontSize = `${fontSize}px`;
    preview.style.padding = `${bottomOffset}px 16px`;
    preview.style.backgroundColor = `rgba(0, 0, 0, ${bgOpacity})`;
  });

  async function extractAudio(file) {
    const arrayBuffer = await file.arrayBuffer();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    const offlineCtx = new OfflineAudioContext(1, audioBuffer.duration * 16000, 16000);
    const source = offlineCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(offlineCtx.destination);
    source.start();
    const resampledBuffer = await offlineCtx.startRendering();
    return resampledBuffer.getChannelData(0);
  }

  function formatTime(s) {
    const hrs = Math.floor(s / 3600),
      mins = Math.floor((s % 3600) / 60),
      secs = Math.floor(s % 60),
      ms = Math.floor((s % 1) * 1000);
    return `${pad(hrs)}:${pad(mins)}:${pad(secs)},${pad(ms, 3)}`;
  }

  function parseTime(str) {
    const parts = str.replace(',', '.').split(':');
    if (parts.length !== 3) return NaN;
    return parseInt(parts[0], 10) * 3600 + parseInt(parts[1], 10) * 60 + parseFloat(parts[2]);
  }

  function pad(num, size = 2) {
    return String(num).padStart(size, '0');
  }

  function showStatus(msg, prog = null) {
    statusText.textContent = msg;
    statusDiv.classList.add('show');
    if (prog !== null) progressFill.style.width = `${prog}%`;
    setTimeout(() => {
      if (prog === 100 || prog === null) statusDiv.classList.remove('show');
    }, 3000);
  }

  function formatSubtitles(chunks) {
    return chunks.map((chunk, i) => ({
      id: i + 1,
      start: chunk.start || 0,
      end: chunk.end || chunk.start + 3,
      text: chunk.text?.trim() || '',
      translatedText: null,
    }));
  }

  function renderTimeline() {
    if (subtitles.length === 0) {
      timelineEditor.innerHTML = '<p style="text-align:center;opacity:0.6;">No subtitles generated yet.</p>';
      return;
    }
    timelineEditor.innerHTML = subtitles
      .map(
        (sub, i) => `
      <div class="timeline-item" data-index="${i}">
        <div><strong>#${sub.id}</strong></div>
        <div class="timeline-controls">
          <input type="text" value="${formatTime(sub.start)}" onchange="updateTimestamp(${i}, 'start', this.value)" placeholder="Start" />
          <input type="text" value="${formatTime(sub.end)}" onchange="updateTimestamp(${i}, 'end', this.value)" placeholder="End" />
          <input type="text" value="${sub.text}" onchange="updateText(${i}, this.value)" placeholder="Subtitle text" />
        </div>
        ${sub.translatedText ? `<div style="margin-top:8px;color:#a0ffa0;">üìù ${sub.translatedText}</div>` : ''}
      </div>
    `
      )
      .join('');
  }

  window.updateTimestamp = (index, field, val) => {
    const seconds = parseTime(val);
    if (!isNaN(seconds)) subtitles[index][field] = seconds;
  };

  window.updateText = (index, val) => {
    subtitles[index].text = val;
  };

  // Initialize status
  showStatus('Welcome! Upload a video and load a model to begin.');
</script>
</body>
</html>
